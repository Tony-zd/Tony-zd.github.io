<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HashMap原理</title>
    <url>/2021/01/09/HashMap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>哈哈</p>
<span id="more"></span>

<h3 id="一、hash和hashcode"><a href="#一、hash和hashcode" class="headerlink" title="一、hash和hashcode"></a>一、hash和hashcode</h3><h4 id="1、百度百科对于hash的解释"><a href="#1、百度百科对于hash的解释" class="headerlink" title="1、百度百科对于hash的解释"></a>1、百度百科对于hash的解释</h4><p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211216085503.png"></p>
<h4 id="2、hashcode"><a href="#2、hashcode" class="headerlink" title="2、hashcode"></a>2、hashcode</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）hash函数计算得出hash值，hash值维护在一张hash表中，整张hash是由hash值组成的；</span><br><span class="line">（2）hashcode就是通过hash函数算出的一种hash值，每个对象都有hashcode，将对象的物理地址通过hash函数计算就得到了hashcode；</span><br><span class="line">（3）对象的hashcode有可能相等，所以hashcode相同，对象不一定相等；对象相等，hashcode一定相同</span><br></pre></td></tr></table></figure>



<h3 id="二、hashcode的应用"><a href="#二、hashcode的应用" class="headerlink" title="二、hashcode的应用"></a>二、hashcode的应用</h3><h4 id="1、对象的hashcode和equals方法"><a href="#1、对象的hashcode和equals方法" class="headerlink" title="1、对象的hashcode和equals方法"></a>1、对象的hashcode和equals方法</h4><p>​        Object类有两个方法：hashcode和equals方法，对于object对象，equals对象是直接比较对象的地址，这个时候和“==”的作用就是一样的，但是像String中，重写了hashcode和equals方法，String的equals方法比较的是对象的值是否相等。</p>
<p>​        有这样两条规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同</span><br><span class="line">2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置</span><br><span class="line">3、如果重写了equals方法，最好也重写hashcode方法</span><br></pre></td></tr></table></figure>



<h4 id="2、HashMap"><a href="#2、HashMap" class="headerlink" title="2、HashMap"></a>2、HashMap</h4><h5 id="（1）、JDK1-7"><a href="#（1）、JDK1-7" class="headerlink" title="（1）、JDK1.7"></a>（1）、JDK1.7</h5><ul>
<li><p>存储结构</p>
<p>1.7的存储结构采用<strong>数组+链表</strong>，其中数组的每个元素为<strong>Entry&lt;K,V&gt;[] table</strong>，table中有四个元素：key、value、hash（key的hashcode值）、next（当前节点的下一个节点，用于处理hash冲突，采用头插法）</p>
<blockquote>
<p>至于为什么会采用头插法，据说是考虑到热点数据的原因，即最近插入的元素也很可能最近会被使用到</p>
</blockquote>
<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211216085535.png"></p>
</li>
<li><p>put和get方法</p>
</li>
</ul>
<h5 id="（2）、JDK1-8"><a href="#（2）、JDK1-8" class="headerlink" title="（2）、JDK1.8"></a>（2）、JDK1.8</h5><ul>
<li><p>存储结构</p>
<p>1.8的存储结构采用<strong>数组+链表+红黑树</strong>，与1.7的区别就是当链表长度大于8<strong>且</strong>节点数组长度大于64的时候，就把链表下所有的节点转为红黑树，否则就进行扩容操作；其中数组的每个元素结构为Node&lt;K,V&gt;[] table，链表的节点采用尾插法</p>
</li>
<li><p>put和get方法</p>
</li>
</ul>
<h5 id="（3）、1-7和1-8的比较"><a href="#（3）、1-7和1-8的比较" class="headerlink" title="（3）、1.7和1.8的比较"></a>（3）、1.7和1.8的比较</h5><ul>
<li>jdk1.7中底层是由<strong>数组（也有叫做“位桶”的）+链表</strong>实现；jdk1.8中底层是由<strong>数组+链表/红黑树</strong>实现</li>
<li>可以存储null键和null值，线程不安全</li>
<li>初始size为<strong>16</strong>，扩容：newsize = oldsize<em>2，*<em>size一定为2的n次幂</em></em></li>
<li>扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入</li>
<li>插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）</li>
<li>当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀</li>
<li>1.7中是<strong>先扩容后插入</strong>新值的，1.8中是<strong>先插值再扩容</strong></li>
</ul>
<h4 id="3、ConcurrentHashMap"><a href="#3、ConcurrentHashMap" class="headerlink" title="3、ConcurrentHashMap"></a>3、ConcurrentHashMap</h4><p>ConcurrentHashMap主要是为了解决HashMap在多线程并发下不安全的问题，HashMap是线程不安全，HashTable是线程安全，但是是全局加锁，效率太低，因此ConcurrentHashMap使用局部加锁，提高并发效率，在1.7和1.8中实现方式有些不同</p>
<h5 id="（1）、JDK1-7-1"><a href="#（1）、JDK1-7-1" class="headerlink" title="（1）、JDK1.7"></a>（1）、JDK1.7</h5><ul>
<li><p>存储结构</p>
<p>结构采用：<strong>数组+Segment+分段锁</strong>，每个Segment都继承了ReentrantLock，因此当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问，但是定位到数据需要两次hash，第一次定位到Segment，第二次定位到链表头部；默认有16个Segment</p>
<img src="HashMap原理\concurrenthashmap.png" style="zoom:50%;" /></li>
</ul>
<h5 id="（2）、JDK1-8-1"><a href="#（2）、JDK1-8-1" class="headerlink" title="（2）、JDK1.8"></a>（2）、JDK1.8</h5><ul>
<li><p>存储结构</p>
<p>1.8的结构与1.7差别较大，不使用Segment，改成<strong>Node数组+链表/红黑树</strong>，与hashmap的1.8结构基本一样，1.8使用CAS+volatile+Synchronized保证线程安全</p>
<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211216085606.jpg"></p>
</li>
<li><p>put和get方法</p>
</li>
</ul>
<h4 id="4、hash冲突"><a href="#4、hash冲突" class="headerlink" title="4、hash冲突"></a>4、hash冲突</h4><ul>
<li>扩容</li>
<li>链表</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Hashmap源码分析</title>
    <url>/2021/02/28/Hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近简单读了一下hashmap的源码</p>
<span id="more"></span>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;<span class="comment">//可序列化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16，默认大小16,2的幂次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">//加载因子，16*0.75=12，达到12时进行扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;<span class="comment">//转成红黑树临界点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;<span class="comment">//转成链表临界点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">//数组长度临界点、</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;<span class="comment">//node数组</span></span><br></pre></td></tr></table></figure>

<h4 id="基础节点结构"><a href="#基础节点结构" class="headerlink" title="基础节点结构"></a>基础节点结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//key的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始容量小于0，则报错</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="comment">//初始容量大于1&lt;&lt;30,则容量为1&lt;&lt;30；这里注意看下扩容时的代码，看下最大值是什么</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//加载因子校验</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tableSizeFor方法"><a href="#tableSizeFor方法" class="headerlink" title="tableSizeFor方法"></a>tableSizeFor方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到大于或等于 cap 的最小2的幂</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="putVar方法"><a href="#putVar方法" class="headerlink" title="putVar方法"></a>putVar方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意括号中进行了大量的赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个空的node数组，节点p，两个变量</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//进行赋值操作，n为数组长度，数组是null或者长度为0，则进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//hashmap的hash算法，初始化节点给p，然后将key、value放进去</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里的e就是要put的节点</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果key值相同，并且hashcode相同，直接将p赋值给e</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果p是一个二叉树，将值放入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前桶是一个链表，循环链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//找到最后都没有找到，则将新值放入链表尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果找到了，则break跳出循环，后面更新value就可以</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;<span class="comment">//修改p的指针，p指向p的next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新值，并返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断大小有没有超过阈值，超过了需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//这个方法在LinkedHashMap中重写了，保证顺序</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p = tab[i = (n - <span class="number">1</span>) &amp; hash</span><br><span class="line">e = p.next</span><br><span class="line">p = e</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC流程源码分析</title>
    <url>/2021/04/15/SpringMVC%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>项目启动扫描url，并存储，用户发起请求，前端控制器根据url分发请求</p>
<span id="more"></span>

<h3 id="建立所有url和controller的对应关系"><a href="#建立所有url和controller的对应关系" class="headerlink" title="建立所有url和controller的对应关系"></a>建立所有url和controller的对应关系</h3><blockquote>
<p>SpringMVC的容器初始化的时候，会建立所有url和controller的对应关系</p>
</blockquote>
<p><strong>ApplicationObjectSupport</strong>里面有一个方法：setApplicationContext(ApplicationContext context)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (context == <span class="keyword">null</span> &amp;&amp; !isContextRequired()) &#123;</span><br><span class="line">			<span class="comment">// Reset internal context state.</span></span><br><span class="line">			<span class="keyword">this</span>.applicationContext = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Initialize with passed-in context.</span></span><br><span class="line">			<span class="keyword">if</span> (!requiredContextClass().isInstance(context)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">						<span class="string">&quot;Invalid application context: needs to be of type [&quot;</span> + requiredContextClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.applicationContext = context;</span><br><span class="line">			<span class="keyword">this</span>.messageSourceAccessor = <span class="keyword">new</span> MessageSourceAccessor(context);</span><br><span class="line">			initApplicationContext(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Ignore reinitialization if same context passed in.</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != context) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">						<span class="string">&quot;Cannot reinitialize with different application context: current one is [&quot;</span> +</span><br><span class="line">						<span class="keyword">this</span>.applicationContext + <span class="string">&quot;], passed-in one is [&quot;</span> + context + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>ApplicationContext 为应用上下文内容，继承BeanFactory，ApplicationContext 的常用子类有三个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathXmlApplicationContext</span><br><span class="line">FileSystemXmlApplicationContext</span><br><span class="line">XmlWebApplicationContext</span><br></pre></td></tr></table></figure></li>
<li><p>注意initApplicationContext(context)方法</p>
<p> 这个方法是由子类AbstractDetectingUrlHandlerMapping实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">    detectHandlers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>detectHandlers()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Looking for URL mappings in application context: &quot;</span> + getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line">    String[] beanNames = (<span class="keyword">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :</span><br><span class="line">            getApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line">	<span class="comment">//取任何我们可以确定URL的bean名称</span></span><br><span class="line">    <span class="comment">// Take any bean name that we can determine URLs for.</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">            <span class="comment">//找到的URL路径：让我们把它看作一个处理程序，保存url和beanName的对应关系</span></span><br><span class="line">            <span class="comment">// URL paths found: Let&#x27;s consider it a handler.</span></span><br><span class="line">            registerHandler(urls, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Rejected bean name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: no URL paths identified&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h3><blockquote>
<p>首先我们知道用户请求都要进过DispatcherServlet，我们就从这里开始分析</p>
</blockquote>
<p><strong>DispatcherServlet的继承情况如图</strong></p>
<img src="SpringMVC流程源码分析\DispatcherServlet.png" style="zoom:100%;" />

<p>从图中可知，DispatcherServlet最终是继承了HttpServlet，实现了Servlet接口，说明这是一个servlet，那么必然有一个service方法，在它的父类FrameworkServlet里面可以找到，如下</p>
<p><strong>service方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override the parent class implementation in order to intercept PATCH</span></span><br><span class="line"><span class="comment"> * requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String method = request.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也是进行的方法的重写，判断是否是PATCH请求</p>
<ul>
<li>equalsIgnoreCase：判断是否相等，不区分大小写</li>
<li>如果是，则执行：processRequest(request, response);</li>
<li>否，则执行父类：super.service(request, response);</li>
</ul>
<p><strong>注意：</strong>这里不仅重写了service方法，还重写了dopost等方法，所有的请求最终都到达<strong>processRequest</strong>方法</p>
<p><img src="D:\GitLocalLibrary\hexo\source_posts\SpringMVC流程源码分析\service等方法.png"></p>
<p><strong>processRequest方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用模板方法，进入DispatcherServlet</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里才发现，最后进入了常说的DispatcherServlet的doService方法，进行请求的转发</p>
<p><strong>doService</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里处理核心逻辑</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>doDispatch方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查是否是文件上传请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = processedRequest != request;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">//取得处理当前请求的controller,这里也称为hanlder,处理器,这里并不是直接返回controller,而是返回的HandlerExecutionChain请求处理器链对象,该对象封装了handler和interceptors.</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="comment">//handler为空，返回404</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            <span class="comment">//获取处理request的处理器适配器handler adapter </span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="comment">//处理 last-modified 请求头</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    String requestUri = urlPathHelper.getRequestUri(request);</span><br><span class="line">                    logger.debug(<span class="string">&quot;Last-Modified value for [&quot;</span> + requestUri + <span class="string">&quot;] is: &quot;</span> + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//拦截器的预处理方法</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">                <span class="comment">//实际的处理器处理请求,返回结果视图对象</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//结果视图对象的处理</span></span><br><span class="line">            applyDefaultViewName(request, mv);</span><br><span class="line">            <span class="comment">//拦截器的后处理方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="comment">//请求成功响应之后的方法</span></span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">        <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://www.cnblogs.com/heavenyes/p/3905844.html#a1">https://www.cnblogs.com/heavenyes/p/3905844.html#a1</a></p>
<p><a href="https://blog.csdn.net/zhangdong2012/article/details/60322922">https://blog.csdn.net/zhangdong2012/article/details/60322922</a></p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>Sublime配置java运行环境</title>
    <url>/2021/07/24/Sublime%E9%85%8D%E7%BD%AEjava%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Sublime Text 3配置java运行环境，附上Sublime Text 3注册码</p>
<span id="more"></span>

<h4 id="1、安装jdk，设置环境变量"><a href="#1、安装jdk，设置环境变量" class="headerlink" title="1、安装jdk，设置环境变量"></a>1、安装jdk，设置环境变量</h4><h4 id="2、修改D-Sublime-Text-3-Packages-Java-sublime-package"><a href="#2、修改D-Sublime-Text-3-Packages-Java-sublime-package" class="headerlink" title="2、修改D:\Sublime Text 3\Packages\Java.sublime-package"></a>2、修改D:\Sublime Text 3\Packages\Java.sublime-package</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">打开压缩包Java.sublime-package</span><br><span class="line">找到JavaC.sublime-build文件，并打开</span><br><span class="line">修改内容：</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;cmd&quot;</span>: [<span class="string">&quot;javac&quot;</span>,<span class="string">&quot;-encoding&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>,<span class="string">&quot;-d&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;$file&quot;</span>, <span class="string">&quot;&amp;&amp;&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;$file_base_name&quot;</span>], </span><br><span class="line"><span class="attr">&quot;working_dir&quot;</span>: <span class="string">&quot;$file_path&quot;</span>, </span><br><span class="line"><span class="attr">&quot;file_regex&quot;</span>: <span class="string">&quot;^(...*?):([0-9]*):?([0-9]*)&quot;</span>,</span><br><span class="line"><span class="attr">&quot;selector&quot;</span>: <span class="string">&quot;source.java&quot;</span>, </span><br><span class="line"><span class="attr">&quot;shell&quot;</span>: <span class="literal">true</span>, </span><br><span class="line"><span class="attr">&quot;encoding&quot;</span>:<span class="string">&quot;cp936&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、注意点"><a href="#3、注意点" class="headerlink" title="3、注意点"></a>3、注意点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编码最好统一成utf-8，项目编码、运行编码</span><br><span class="line">cp936为了保证在sublime控制台显示正常</span><br><span class="line">&quot;-d&quot;,&quot;.&quot; ：为了能够找到编译后的class文件</span><br><span class="line">working_dir：定位到执行Java的路径</span><br></pre></td></tr></table></figure>

<h4 id="4、注册码"><a href="#4、注册码" class="headerlink" title="4、注册码"></a>4、注册码</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Member J2TeaM</span><br><span class="line">Single User License</span><br><span class="line">EA7E<span class="number">-1011316</span></span><br><span class="line">D7DA350E <span class="number">1</span>B8B0760 <span class="number">972</span>F8B60 F3E64036</span><br><span class="line">B9B4E234 F356F38F <span class="number">0</span>AD1E3B7 <span class="number">0E9</span>C5FAD</span><br><span class="line">FA0A2ABE <span class="number">25</span>F65BD8 D51458E5 <span class="number">3923</span>CE80</span><br><span class="line"><span class="number">87428428</span> <span class="number">79079</span>A01 AA69F319 A1AF29A4</span><br><span class="line">A684C2DC <span class="number">0</span>B1583D4 <span class="number">19</span>CBD290 <span class="number">217618</span>CD</span><br><span class="line"><span class="number">5653E0</span>A0 BACE3948 BB2EE45E <span class="number">422</span>D2C87</span><br><span class="line">DD9AF44B <span class="number">99</span>C49590 D2DBDEE1 <span class="number">75860</span>FD2</span><br><span class="line"><span class="number">8</span>C8BB2AD B2ECE5A4 EFC08AF2 <span class="number">25</span>A9B864</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环常见用法</title>
    <url>/2021/01/06/for%E5%BE%AA%E7%8E%AF%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>前段时间由于项目中使用的for循环较多，踩了一些坑，在此记录一下</p>
</blockquote>
<span id="more"></span>

<h3 id="一、for循环使用方式"><a href="#一、for循环使用方式" class="headerlink" title="一、for循环使用方式"></a>一、for循环使用方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、fori循环</span><br><span class="line">2、Interator迭代器循环</span><br><span class="line">3、foreach增强循环</span><br><span class="line">4、lamda表达式</span><br></pre></td></tr></table></figure>

<h3 id="二、注意点"><a href="#二、注意点" class="headerlink" title="二、注意点"></a>二、注意点</h3><ol>
<li><p>删除使用迭代器：每次删除都会导致集合内容的变化，导致下标变化，数组溢出</p>
</li>
<li><p>多层for循环跳出：</p>
<p>（1）break ：跳出内层循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void testForOut()&#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">            System.out.println(&quot;i=&quot;+i+&quot; | j=&quot;+j);</span><br><span class="line">            if(j==1)&#123;</span><br><span class="line">                System.out.println(&quot;查询成功，跳出内层循环&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;循环结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">输出：j每次都是到2结束，i一直到4</span><br><span class="line">i=0 | j=0</span><br><span class="line">i=0 | j=1</span><br><span class="line">查询成功，跳出内层循环</span><br><span class="line">i=1 | j=0</span><br><span class="line">i=1 | j=1</span><br><span class="line">查询成功，跳出内层循环</span><br><span class="line">i=2 | j=0</span><br><span class="line">i=2 | j=1</span><br><span class="line">查询成功，跳出内层循环</span><br><span class="line">i=3 | j=0</span><br><span class="line">i=3 | j=1</span><br><span class="line">查询成功，跳出内层循环</span><br><span class="line">i=4 | j=0</span><br><span class="line">i=4 | j=1</span><br><span class="line">查询成功，跳出内层循环</span><br><span class="line">循环结束</span><br></pre></td></tr></table></figure>

<p>（2）break out：在外层循环之前添加 out: 标签，跳出外层循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void testForOut()&#123;</span><br><span class="line">    out:for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">            System.out.println(&quot;i=&quot;+i+&quot; | j=&quot;+j);</span><br><span class="line">            if(j==1)&#123;</span><br><span class="line">                System.out.println(&quot;查询成功，跳出内层循环&quot;);</span><br><span class="line">                break out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;循环结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">i=0 | j=0</span><br><span class="line">i=0 | j=1</span><br><span class="line">查询成功，跳出内层循环</span><br><span class="line">循环结束</span><br></pre></td></tr></table></figure>

<p>（3）continue：此次循环不再往下执行，跳到下一次循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void testForOut()&#123;</span><br><span class="line">    for (int j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">        System.out.println(&quot;j=&quot;+j);</span><br><span class="line">        if(j==1)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;执行内层循环&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;循环结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：j=1时，没有输出，直接到下一次循环</span><br><span class="line">j=0</span><br><span class="line">执行内层循环</span><br><span class="line">j=1</span><br><span class="line">j=2</span><br><span class="line">执行内层循环</span><br><span class="line">j=3</span><br><span class="line">执行内层循环</span><br><span class="line">j=4</span><br><span class="line">执行内层循环</span><br><span class="line">循环结束</span><br></pre></td></tr></table></figure>

<p>（4）continue out：使用out：标签，与break out用法类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void testForOut()&#123; </span><br><span class="line">    out:for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">            System.out.println(&quot;i=&quot;+i+&quot; | j=&quot;+j);</span><br><span class="line">            if(j==0)&#123;</span><br><span class="line">                continue out;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;执行内层循环&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;循环结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：每次j=0就直接进入外层循环的下一次</span><br><span class="line">i=0 | j=0</span><br><span class="line">i=1 | j=0</span><br><span class="line">i=2 | j=0</span><br><span class="line">i=3 | j=0</span><br><span class="line">i=4 | j=0</span><br><span class="line">循环结束</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo发布博客常用命令</title>
    <url>/2021/01/06/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>暂时写下创建博客到发布博客的命令，后续逐步补充其他命令及配置</p>
<span id="more"></span>

<h4 id="1、创建，预览和发布"><a href="#1、创建，预览和发布" class="headerlink" title="1、创建，预览和发布"></a>1、创建，预览和发布</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">完成命令</span><br><span class="line">    hexo new &quot;postName&quot; #新建文章</span><br><span class="line">    hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">    hexo generate #生成静态页面至public目录</span><br><span class="line">    hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">    hexo deploy #部署到GitHub</span><br><span class="line">    hexo help  # 查看帮助</span><br><span class="line">    hexo version  #查看Hexo的版本</span><br><span class="line">缩写：</span><br><span class="line">    hexo n == hexo new</span><br><span class="line">    hexo g == hexo generate</span><br><span class="line">    hexo s == hexo server</span><br><span class="line">    hexo d == hexo deploy</span><br><span class="line">组合：</span><br><span class="line">	hexo s -g #生成并本地预览</span><br><span class="line">	hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>

<h4 id="2、字体修改"><a href="#2、字体修改" class="headerlink" title="2、字体修改"></a>2、字体修改</h4><ul>
<li><p>找到主题的配置文件：D:\GitLocalLibrary\hexo\themes\hexo-theme-next\<strong>_config.yml</strong> </p>
</li>
<li><p>找到font配置项，如下图：</p>
<img src="hexo常用命令及配置/字体.PNG" style="zoom:50%;" />

<p>global为全局配置项，family设置字体（Noto Serif SC），size设置大小（默认是1，就是16px），我用的是0.8</p>
</li>
</ul>
<h4 id="3、使用Typora写博客，上传图片问题"><a href="#3、使用Typora写博客，上传图片问题" class="headerlink" title="3、使用Typora写博客，上传图片问题"></a>3、使用Typora写博客，上传图片问题</h4><p>参考文章：</p>
<p><a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</a></p>
<p>注意点：</p>
<ul>
<li><p>插件下载</p>
</li>
<li><p>图片路径修改</p>
</li>
<li><p>存放图片的文件夹</p>
</li>
<li><p>在Typora上有配置项，可以在复制的时候将图片同步复制到对应目录下面</p>
<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/image-20210724101758547.png" alt="image-20210724101758547"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>java动态代理</title>
    <url>/2021/02/28/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>java静态代理和动态代理，并总结主要应用场景。</p>
<span id="more"></span>

<h3 id="为什么需要代理"><a href="#为什么需要代理" class="headerlink" title="为什么需要代理"></a>为什么需要代理</h3><p>代理本质上是用一个新的对象去代理真实对象，在不修改原本类的情况下，处理真实对象的方法，并扩展一些额外的功能，比如如果需要给每个类添加日志功能，如果没有代理，则需要在每个类打印日志，代码量太多且重复。</p>
<h3 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h3><h4 id="1、静态代理"><a href="#1、静态代理" class="headerlink" title="1、静态代理"></a>1、静态代理</h4><ul>
<li><p>如何设计静态代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、静态代理的代理类和真实类需要实现同一个接口</span><br><span class="line">2、有三个角色：抽象角色、代理角色、真实角色</span><br><span class="line">3、实现步骤</span><br><span class="line">	创建业务接口</span><br><span class="line">	创建业务实现类：这是主业务类</span><br><span class="line">	创建另外一个业务实现类：这是辅助增强类（代理类），可以增加额外功能</span><br></pre></td></tr></table></figure></li>
<li><p>代理示例</p>
<p>（1）创建接口，也就是抽象角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.staticproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/7/12</span><br><span class="line"> */</span><br><span class="line">public interface ITestStaticProxy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 打印接口</span><br><span class="line">     */</span><br><span class="line">    public void println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建业务类，也就是真实角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.staticproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/7/12</span><br><span class="line"> */</span><br><span class="line">public class TestStaticProxy implements ITestStaticProxy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 实现业务接口</span><br><span class="line">     */</span><br><span class="line">    public void println() &#123;</span><br><span class="line">        System.out.println(&quot;my name is sunt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）创建代理类，也就是代理角色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.staticproxy;</span><br><span class="line">/**</span><br><span class="line"> * 静态代理理解、实现</span><br><span class="line"> *</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/7/12</span><br><span class="line"> */</span><br><span class="line">public class StaticProxy implements ITestStaticProxy&#123;</span><br><span class="line">    private TestStaticProxy testStaticProxy;</span><br><span class="line">    /**</span><br><span class="line">     * 注意其中的写法：实现接口方法，并调用TestStaticProxy方法</span><br><span class="line">     * 我们可以在调用业务接口前后增加想要的功能</span><br><span class="line">     */</span><br><span class="line">    public void println() &#123;</span><br><span class="line">        if(null == testStaticProxy)&#123;</span><br><span class="line">            testStaticProxy = new TestStaticProxy();</span><br><span class="line">        &#125;</span><br><span class="line">        //before</span><br><span class="line">        System.out.println(&quot;调用之前&quot;);</span><br><span class="line">        //调用打印方法</span><br><span class="line">        testStaticProxy.println();</span><br><span class="line">        //after</span><br><span class="line">        System.out.println(&quot;调用之后&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.staticproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/7/12</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //调用StaticProxy增加业务类</span><br><span class="line">        StaticProxy staticProxy = new StaticProxy();</span><br><span class="line">        staticProxy.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印内容：</span><br><span class="line"> *</span><br><span class="line"> * 调用之前</span><br><span class="line"> * my name is sunt</span><br><span class="line"> * 调用之后</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<p>静态代理其实还比较好理解，就是在一个增强类里面调用原有方法，处理额外逻辑。我在一个OA项目中见到是这样使用静态代理：项目为了减少数据库压力，设计了缓存，用来存储经常使用的数据，所以写了一个代理类，一个真实类，在接口请求时，由于代理类使用了**@Primary**，所以接口请求会默认进入代理类，如果是查询会直接返回缓存数据，如果是更新插入，会先更新缓存，在调用真实类方法，进行入库操作。静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于两个业务类功能本质上是相同的，增强类只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</p>
</li>
</ul>
<h4 id="2、jdk动态代理"><a href="#2、jdk动态代理" class="headerlink" title="2、jdk动态代理"></a>2、jdk动态代理</h4><ul>
<li><p>为什么需要动态代理</p>
<p>代码运行时动态地创建一个 Proxy代理类，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了</p>
</li>
<li><p>如何设计jdk动态代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、创建业务类接口，并创建其实现类</span><br><span class="line">2、实现InvocationHandler接口，创建动态代理类，并注入真实对象</span><br><span class="line">3、使用Proxy类生成动态代理对象，然后调用真实对象方法</span><br></pre></td></tr></table></figure></li>
<li><p>代码示例</p>
<p>（1）创建业务类接口（对于jdk动态代理是必须的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.dynamicproxy;</span><br><span class="line">/**</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/7/12</span><br><span class="line"> */</span><br><span class="line">public interface ITestDynamicproxy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 打印接口</span><br><span class="line">     */</span><br><span class="line">    public void println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建业务类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.dynamicproxy;</span><br><span class="line">/**</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/7/12</span><br><span class="line"> */</span><br><span class="line">public class TestDynamicproxy implements ITestDynamicproxy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 实现业务接口</span><br><span class="line">     */</span><br><span class="line">    public void println() &#123;</span><br><span class="line">        System.out.println(&quot;my name is sunt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）创建动态代理类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.dynamicproxy;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">/**</span><br><span class="line"> * 动态代理实现类</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/7/12</span><br><span class="line"> */</span><br><span class="line">public class Dynamicproxy implements InvocationHandler &#123;</span><br><span class="line">    private Object testDynamicproxy;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法注入真实对象</span><br><span class="line">     * @param testDynamicproxy</span><br><span class="line">     */</span><br><span class="line">    public Dynamicproxy(Object testDynamicproxy)&#123;</span><br><span class="line">        this.testDynamicproxy = testDynamicproxy;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 实现其唯一的方法invoke</span><br><span class="line">     * 三个参数指：某一个 业务类对象 的某一个 方法 的 入参</span><br><span class="line">     * @param proxy</span><br><span class="line">     * @param method</span><br><span class="line">     * @param args</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //before</span><br><span class="line">        System.out.println(&quot;调用之前&quot;);</span><br><span class="line">        //调用业务实现类方法</span><br><span class="line">        Object object = method.invoke(testDynamicproxy,args);</span><br><span class="line">        //after</span><br><span class="line">        System.out.println(&quot;调用之后&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.dynamicproxy;</span><br><span class="line"></span><br><span class="line">import reflect.staticproxy.StaticProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/7/12</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建业务类对象 ：注意通过接口生成对象</span><br><span class="line">        ITestDynamicproxy testDynamicproxy = new TestDynamicproxy();</span><br><span class="line">        //创建handler对象，并初始化真实对象</span><br><span class="line">        InvocationHandler dynamicproxy = new Dynamicproxy(testDynamicproxy);</span><br><span class="line">        //使用proxy类生成动态代理对象 ：注意通过接口生成对象</span><br><span class="line">        //三个参数：类加载器、真实对象实现的接口、动态代理类</span><br><span class="line">        ITestDynamicproxy testDynamicproxy1 =(ITestDynamicproxy) </span><br><span class="line">        Proxy.newProxyInstance(dynamicproxy.getClass().getClassLoader(),</span><br><span class="line">        					testDynamicproxy.getClass().getInterfaces(),</span><br><span class="line">        					dynamicproxy);</span><br><span class="line">        //调用方法</span><br><span class="line">        testDynamicproxy1.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 打印内容：</span><br><span class="line"> *</span><br><span class="line"> * 调用之前</span><br><span class="line"> * my name is sunt</span><br><span class="line"> * 调用之后</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<p>jdk动态代理解决了静态代理代码冗余，动态生成代理对象，同时，动态代理的必须先实现<strong>InvocationHandler</strong>接口，然后使用<strong>Proxy</strong>类中的<strong>newProxyInstance</strong>方法动态的创建代理类，这就导致了动态代理只能代理接口。</p>
</li>
</ul>
<h4 id="3、cglib动态代理"><a href="#3、cglib动态代理" class="headerlink" title="3、cglib动态代理"></a>3、cglib动态代理</h4><ul>
<li><p>如何设计cglib动态代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、创建目标类</span><br><span class="line">2、实现MethodInterceptor接口，创建代理类</span><br><span class="line">3、创建Enhancer对象，类似于JDK动态代理的Proxy类</span><br><span class="line">4、设置目标类的字节码文件</span><br><span class="line">5、设置回调函数（就是代理类）</span><br><span class="line">6、调用Enhancer的creat方法就是正式创建代理类</span><br><span class="line">7、调用真实对象方法</span><br></pre></td></tr></table></figure></li>
<li><p>代码示例</p>
<p>（1）创建目标业务类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.cglibproxy;</span><br><span class="line">/**</span><br><span class="line"> * 目标类</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/10/24</span><br><span class="line"> */</span><br><span class="line">public class Person &#123;</span><br><span class="line">    </span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;xx在吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建代理类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.cglibproxy;</span><br><span class="line"></span><br><span class="line">import org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line">import org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">/**</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/10/24</span><br><span class="line"> */</span><br><span class="line">public class MyMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;这里是对目标类进行增强！！！&quot;);</span><br><span class="line">        //注意这里的方法调用，不是用反射</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package reflect.cglibproxy;</span><br><span class="line"></span><br><span class="line">import org.springframework.cglib.core.DebuggingClassWriter;</span><br><span class="line">import org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2020/10/24</span><br><span class="line"> */</span><br><span class="line">public class CglibTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //在指定目录下生成动态代理类，我们可以反编译看一下里面到底是一些什么东西</span><br><span class="line">        //System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:\\java\\java_workapace&quot;);</span><br><span class="line"></span><br><span class="line">        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        //设置目标类的字节码文件</span><br><span class="line">        enhancer.setSuperclass(Person.class);</span><br><span class="line">        //设置回调函数</span><br><span class="line">        enhancer.setCallback(new MyMethodInterceptor());</span><br><span class="line">        //这里的creat方法就是正式创建代理类</span><br><span class="line">        Person proxyDog = (Person)enhancer.create();</span><br><span class="line">        //调用代理类的eat方法</span><br><span class="line">        proxyDog.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如何理解回调函数</p>
<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211216090340.jpg"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>putty导出日志乱字符</title>
    <url>/2021/01/24/putty%E5%AF%BC%E5%87%BA%E6%97%A5%E5%BF%97%E4%B9%B1%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>putty乱码问题，一种是控制台乱码，一种是导出日志乱码</p>
<span id="more"></span>

<h4 id="1、控制台乱码，按照如下配置"><a href="#1、控制台乱码，按照如下配置" class="headerlink" title="1、控制台乱码，按照如下配置"></a>1、控制台乱码，按照如下配置</h4><p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211216085830.jpg"></p>
<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211216085904.jpg"></p>
<h4 id="2、putty-log乱码"><a href="#2、putty-log乱码" class="headerlink" title="2、putty.log乱码"></a>2、putty.log乱码</h4><p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211216085927.jpg"></p>
]]></content>
      <categories>
        <category>putty</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令记录</title>
    <url>/2021/09/12/linux%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>日常使用过程中的linux命令记录</p>
<span id="more"></span>

<h4 id="安装linux命令的步骤"><a href="#安装linux命令的步骤" class="headerlink" title="安装linux命令的步骤"></a>安装linux命令的步骤</h4><ol>
<li><p>当发现某个命令不存在之后，先判断这个命令是谁提供的，如：vim</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum provides vim</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211215215619.png"></p>
</li>
<li><p>安装vim命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install vim</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>可视化的监控 spring-boot 程序的运行状态</title>
    <url>/2021/03/11/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9A%84%E7%9B%91%E6%8E%A7-spring-boot-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>spring-boot 集成 spring-boot-admin 来可视化的监控 spring-boot 程序的运行状态，可以与 actuator 互相搭配使用</p>
<span id="more"></span>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title> springboot读取配置文件</title>
    <url>/2021/02/28/springboot%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>本 demo 演示如何获取配置文件的自定义配置，以及如何多环境下的配置文件信息的获取</p>
<span id="more"></span>

<h3 id="通过配置文件赋值"><a href="#通过配置文件赋值" class="headerlink" title="通过配置文件赋值"></a>通过配置文件赋值</h3><h4 id="1、使用-Value注解和“-”"><a href="#1、使用-Value注解和“-”" class="headerlink" title="1、使用@Value注解和“$()”"></a>1、使用@Value注解和“$()”</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data//@Data注解是lombok插件提供，注解在类上, 为类提供读写属性, 此外还提供了 equals()、hashCode()、toString() 方法</span><br><span class="line">@Component</span><br><span class="line">public class ApplicationProperty &#123;</span><br><span class="line">    @Value(&quot;$&#123;application.name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Value(&quot;$&#123;application.version&#125;&quot;)</span><br><span class="line">    private String version;</span><br><span class="line">&#125;</span><br><span class="line">配置文件如下：</span><br><span class="line">application:</span><br><span class="line">  name: 嘿嘿</span><br><span class="line">  version: 1.1.1</span><br></pre></td></tr></table></figure>

<h4 id="2、使用ConfigurationProperties注解组合匹配"><a href="#2、使用ConfigurationProperties注解组合匹配" class="headerlink" title="2、使用ConfigurationProperties注解组合匹配"></a>2、使用ConfigurationProperties注解组合匹配</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@ConfigurationProperties(prefix = &quot;developer&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class DeveloperProperty &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String website;</span><br><span class="line">    private String qq;</span><br><span class="line">    private String phoneNumber;</span><br><span class="line">&#125;</span><br><span class="line">配置文件如下：</span><br><span class="line">developer:</span><br><span class="line">  name: 嘿嘿</span><br><span class="line">  website: http://baidu.com</span><br><span class="line">  qq: 123456</span><br><span class="line">  phone-number: 1273648</span><br><span class="line">查找方式：developer+属性名（属性名需要和配置文件一样）</span><br></pre></td></tr></table></figure>

<h4 id="3、多个配置文件切换"><a href="#3、多个配置文件切换" class="headerlink" title="3、多个配置文件切换"></a>3、多个配置文件切换</h4><p>项目启动时，会先根据spring.profiles.active的配置加载对应的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /demo</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod（这是有效的配置文件）</span><br><span class="line">    </span><br><span class="line">两个配置文件：</span><br><span class="line">application-dev.xml</span><br><span class="line">application-prod.xml</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>监控 spring-boot 的启动和运行状态</title>
    <url>/2021/03/10/%E7%9B%91%E6%8E%A7-spring-boot-%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p>spring-boot 集成 spring-boot-starter-actuator 用于监控 spring-boot 的启动和运行状态</p>
<span id="more"></span>

<h3 id="添加监控场景依赖"><a href="#添加监控场景依赖" class="headerlink" title="添加监控场景依赖"></a>添加监控场景依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="可以添加spring-boot-starter-security用于指定用户访问actuator接口，来保证actuator暴露接口的安全性"><a href="#可以添加spring-boot-starter-security用于指定用户访问actuator接口，来保证actuator暴露接口的安全性" class="headerlink" title="可以添加spring-boot-starter-security用于指定用户访问actuator接口，来保证actuator暴露接口的安全性"></a>可以添加spring-boot-starter-security用于指定用户访问actuator接口，来保证actuator暴露接口的安全性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>指定用户访问</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若要访问端点信息，需要配置用户名和密码</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">sunt</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>不限定用户访问</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有的用户都可以用Actuator</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>management.security.enabled</code>的值是false的话，除开health接口还依赖<code>endpoints.health.sensitive</code>的配置外，其他接口都不需要输入用户名和密码了</li>
<li>actuator暴露的health接口权限是由两个配置： <code>management.security.enabled</code> 和 <code>endpoints.health.sensitive</code>组合的结果进行返回的。</li>
</ul>
</li>
<li><p>所有可查看接口</p>
<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211216090500.jpg"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>typora上传图片</title>
    <url>/2021/02/28/typora%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E4%BD%BF%E7%94%A8Gitee%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>typora上传图片，使用Gitee作为图床</p>
<span id="more"></span>

<h4 id="gitee创建仓库"><a href="#gitee创建仓库" class="headerlink" title="gitee创建仓库"></a>gitee创建仓库</h4><p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211204163420.png" alt="image-20211204163418705"></p>
<h4 id="设置私人令牌"><a href="#设置私人令牌" class="headerlink" title="设置私人令牌"></a>设置私人令牌</h4><p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211204163702.png" alt="image-20211204163700624"></p>
<h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p><a href="https://nodejs.org/en/download/">下载地址</a>，选择Windows版本</p>
<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211204163847.png" alt="image-20211204163846147"></p>
<h4 id="cmd进入插件位置，执行以下命令"><a href="#cmd进入插件位置，执行以下命令" class="headerlink" title="cmd进入插件位置，执行以下命令"></a>cmd进入插件位置，执行以下命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\picgo.exe install smms-user</span><br><span class="line">.\picgo.exe install gitee-uploader</span><br><span class="line">.\picgo.exe install github-plus</span><br><span class="line">.\picgo.exe install rename-file</span><br><span class="line">.\picgo.exe install super-prefix</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211204164124.png" alt="image-20211204164122863"></p>
<h4 id="验证图片上传"><a href="#验证图片上传" class="headerlink" title="验证图片上传"></a>验证图片上传</h4><p><img src="https://gitee.com/zhongda-st/images/raw/master/typora/20211204164403.png" alt="image-20211204164401510"></p>
]]></content>
      <categories>
        <category>typora</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解</title>
    <url>/2021/01/16/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>Java自定义注解涉及到的知识点：元注解及含义、反射及反射工具类的使用</p>
<span id="more"></span>

<h4 id="一、什么是Java注解"><a href="#一、什么是Java注解" class="headerlink" title="一、什么是Java注解"></a>一、什么是Java注解</h4><blockquote>
<p>从JDK5开始，java增加了对元数据（描述数据属性的信息）的支持。其实说白就是代码里的特殊标志，这些标志可以在编译，类加载，运行时被读取，并执行相应的处理，以便于其他工具补充信息或者进行部署。</p>
</blockquote>
<h4 id="二、元注解"><a href="#二、元注解" class="headerlink" title="二、元注解"></a>二、元注解</h4><p>在<strong>java.lang.annotation</strong>中提供了元注解，可以用这些注解来自定义注解，主要使用其中的四个元注解：@Target、@Retention、@Inherited、@Documented。</p>
<ol>
<li>@Target：用于描述注解的修饰范围<ul>
<li>METHOD：用于描述方法</li>
<li>PACKAGE：用于描述包</li>
<li>PARAMETER：用于描述方法变量</li>
<li>TYPE：用于描述类、接口或enum类型</li>
</ul>
</li>
<li>@Retention：注解的生命周期<ul>
<li>SOURCE：作用于源文件，编译时无效</li>
<li>CLASS：存在于编译后的class文件中，运行时无效</li>
<li>RUNTIME：运行时有效（通常使用这种方式，可以利用到反射特性，处理业务逻辑）</li>
</ul>
</li>
<li>@Inherited：表明注解可以被继承，如果父类使用了这个注解，在子类也生效</li>
<li>@Documented：注解包含在javadoc中</li>
</ol>
<h4 id="三、自定义注解"><a href="#三、自定义注解" class="headerlink" title="三、自定义注解"></a>三、自定义注解</h4><p>自定义注解示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义注解示例</span><br><span class="line"> * @author sunt</span><br><span class="line"> * @create 2021/1/16</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.METHOD)//作用在方法上</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)//运行时有效</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Sunt &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用default指定默认值，如果没有默认值必须要指定值</span><br><span class="line">     * 参数名格式，注意有括号</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四、自定义注解的应用（待补充代码示例）"><a href="#四、自定义注解的应用（待补充代码示例）" class="headerlink" title="四、自定义注解的应用（待补充代码示例）"></a>四、自定义注解的应用（待补充代码示例）</h4><p>​        目前我在项目中对于自定义注解的使用主要是用来扫描后台java方法，展示在前端，让用户选择方法，输入参数，执行方法；其中对于注解方法的扫描主要使用反射获取使用了自定义注解的类和方法，然后组装数据，返回到前端；</p>
<p>​        这里对于扫描方法的注解解析器设计方案值得思考：由于使用了这些注解的方法在运行期是不会变化的，所以只需要扫描一次就可以了（提升性能），所以在设计的时候，有以下几点</p>
<ul>
<li>使用静态ConcurrentHashMap存储扫描出来的方法</li>
<li>保证这个类只执行一次，有两种方式：（待整理，多线程数据交换、线程同步）<ul>
<li>使用java原子包atomic，AtomicBoolean 里面的compareAndSet方法</li>
<li>使用volatile关键字，保证线程见的可见性</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
</search>
